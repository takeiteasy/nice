#!/usr/bin/env lua

local amalg = dofile("./deps/lua-amalg/amalg.lua")

local nicepkg 
local ext = "dylib"
if package.config:sub(1,1) == "\\" then
    ext = "dll"
elseif io.open("/proc/version") then
    ext = "so"
end
local lib_path = "./build/nicepkg." .. ext
local ok, err = package.loadlib(lib_path, "luaopen_nicepkg")
if not ok then
    error("Failed to load nicepkg dynamic library (" .. lib_path .. "): " .. err)
end
nicepkg = ok()

local function print_usage()
    print("Usage: lua nicepkg.lua [options] <input files>")
    print("")
    print("Packaging tool for the NICE engine")
    print("")
    print("Arguments:")
    print("  <input files>        Path(s) to the input file(s) to package")
    print("")
    print("Options:")
    print("  --help, -h           Show this help message")
    print("  --explode, -x FILE   Explode the specified image file into tiles before converting")
    print("  --as, -a FILE        Specify the output file for the last asset (default: relative path to file)")
    print("  --width WIDTH        Set the tile width (default: 64)")
    print("  --height HEIGHT      Set the tile height (default: 64)")
    print("  --padding PADDING    Set the padding between tiles (default: 4)")
    print("  --channels CHANNELS  Force number of channels (3=RGB, 4=RGBA, 0=auto) (default: 0)")
    print("  --colorspace SPACE   Set the colorspace (0=sRGB, 1=linear) (default: 0)")
    print("  --keep/-k            Keep files generated by nicepkg")
    print("  --main/-m FILE      Specify the main Lua file to run (default: main.lua or first .lua file found)")
    print("  --amalg-out FILE    Specify the output file for the amalgamation (default: main.lua)")
    print("  --                  After `--` all remaining arguments are forwarded to amalg.lua")
    print("")
    print("For more information, see <https://github.com/takeiteasy/nice>")
end

local function generate_output_path(input_path)
    local last_slash = input_path:find("/[^/]*$")
    local base_start = last_slash and last_slash + 1 or 1
    local last_dot = input_path:find("%.[^%.]*$", base_start)
    local base_len
    if last_dot then
        base_len = last_dot - base_start
    else
        base_len = #input_path - base_start + 1
    end
    local path_prefix = last_slash and input_path:sub(1, last_slash) or ""
    local base = input_path:sub(base_start, base_start + base_len - 1)
    return path_prefix .. base .. ".qoi"
end

local function generate_exploded_path(input_path)
    local last_dot = input_path:find("%.[^%.]*$")
    if not last_dot then
        return input_path .. ".exploded"
    end
    local base = input_path:sub(1, last_dot - 1)
    local ext = input_path:sub(last_dot)
    return base .. ".exploded" .. ext
end

local function explode_image(input_path, tile_width, tile_height, padding)
    local output_path = generate_exploded_path(input_path)
    print("Processing '" .. input_path .. "' -> '" .. output_path .. "'")

    local width, height, channels, data = nicepkg.load(input_path)
    if not width then
        error("Failed to load image '" .. input_path .. "': " .. height .. ", skipping\n")
    end

    if tile_width > width or tile_height > height then
        error("Tile size larger than image '" .. input_path .. "': tile size: " .. tile_width .. "," .. tile_height .. ", image size: " .. width .. "," .. height .. ", skipping\n")
    end

    if width % tile_width ~= 0 or height % tile_height ~= 0 then
        error("Tile size is not multiple of image size for '" .. input_path .. "': tile size: " .. tile_width .. "," .. tile_height .. ", image size: " .. width .. "," .. height .. ", skipping\n")
    end

    local rows = height // tile_height
    local cols = width // tile_width
    local new_width = (cols * tile_width) + ((cols + 1) * padding)
    local new_height = (rows * tile_height) + ((rows + 1) * padding)

    -- Create new image data as a table of pixels (each 4 bytes)
    local new_data_table = {}
    for i = 1, new_width * new_height do
        new_data_table[i] = '\0\0\0\0'  -- default transparent
    end

    for y = 0, rows - 1 do
        for x = 0, cols - 1 do
            -- Source rectangle
            local src_x = x * tile_width
            local src_y = y * tile_height

            -- Destination
            local dx = x * tile_width + ((x + 1) * padding)
            local dy = y * tile_height + ((y + 1) * padding)

            for tile_y = 0, tile_height - 1 do
                for tile_x = 0, tile_width - 1 do
                    local src_pixel_x = src_x + tile_x
                    local src_pixel_y = src_y + tile_y
                    local src_index = (src_pixel_y * width + src_pixel_x) * 4 + 1
                    local pixel = data:sub(src_index, src_index + 3)

                    local dst_pixel_x = dx + tile_x
                    local dst_pixel_y = dy + tile_y
                    local dst_index = (dst_pixel_y * new_width + dst_pixel_x) + 1

                    new_data_table[dst_index] = pixel
                end
            end
        end
    end

    local new_data = table.concat(new_data_table)

    local success = nicepkg.write_png(output_path, new_width, new_height, 4, new_data, new_width * 4)
    if success then
        print("Successfully exploded image: " .. input_path .. " -> " .. output_path)
    else
        error("Failed to save output image '" .. output_path .. "', skipping\n")
    end
    return output_path
end

local function generate_output_path(input_path, new_ext)
    local last_slash = input_path:find("/[^/]*$")
    local base_start = last_slash and last_slash + 1 or 1
    local last_dot = input_path:find("%.[^%.]*$", base_start)
    local base_len
    if last_dot then
        base_len = last_dot - base_start
    else
        base_len = #input_path - base_start + 1
    end
    local path_prefix = last_slash and input_path:sub(1, last_slash) or ""
    local base = input_path:sub(base_start, base_start + base_len - 1)
    return path_prefix .. base .. "." .. new_ext
end

local function convert_to_qoi(input_path, force_channels, colorspace)
    local output_path = generate_output_path(input_path, "qoi")
    print("Converting '" .. input_path .. "' to '" .. output_path .. "'")

    local width, height, channels, data = nicepkg.load(input_path)
    if not width then
        error("Failed to load image '" .. input_path .. "': " .. height .. ", skipping\n")
    end

    local output_channels = force_channels > 0 and force_channels or channels
    print("Loaded image: " .. width .. "x" .. height .. ", " .. channels .. " channels -> " .. output_channels .. " channels")

    local qoi_data = nicepkg.qoi_encode(data, width, height, output_channels, colorspace)
    if not qoi_data then
        error("Failed to encode image '" .. input_path .. "' to QOI format, skipping\n")
    end

    print("Encoded to QOI: " .. #qoi_data .. " bytes")

    local file = io.open(output_path, "wb")
    if not file then
        error("Failed to open output file '" .. output_path .. "', skipping\n")
    end

    file:write(qoi_data)
    file:close()

    print("Successfully converted '" .. input_path .. "' -> " .. output_path .. " ")
    return output_path
end

local function load_audio_file(input_path)
    local ext = input_path:match("%.[^.]+$")
    if not ext then
        return nil, "No file extension found"
    end
    ext = ext:lower()

    local loader
    if ext == ".wav" then
        loader = nicepkg.load_wav
    elseif ext == ".ogg" then
        loader = nicepkg.load_ogg
    elseif ext == ".mp3" then
        loader = nicepkg.load_mp3
    elseif ext == ".flac" then
        loader = nicepkg.load_flac
    else
        return nil, "Unsupported file format '" .. ext .. "'"
    end

    return loader(input_path)
end

local function convert_to_qoa(input_path)
    local output_path = generate_output_path(input_path, "qoa")
    print("Converting '" .. input_path .. "' to '" .. output_path .. "'")

    local channels, samplerate, samples, data = load_audio_file(input_path)
    if not channels then
        error("Failed to load audio '" .. input_path .. "': " .. samplerate .. ", skipping\n")
    end

    print("Loaded audio: " .. samples .. " samples, " .. channels .. " channels, " .. samplerate .. " Hz")

    local qoa_data = nicepkg.qoa_encode(data, channels, samplerate, samples)
    if not qoa_data then
        error("Failed to encode audio '" .. input_path .. "' to QOA format, skipping\n")
    end

    print("Encoded to QOA: " .. #qoa_data .. " bytes")

    local file = io.open(output_path, "wb")
    if not file then
        error("Failed to open output file '" .. output_path .. "', skipping\n")
    end

    file:write(qoa_data)
    file:close()

    print("Successfully converted '" .. input_path .. "' -> " .. output_path .. " ")
    return output_path
end

function table_contains(tbl, x)
    found = false
    for _, v in pairs(tbl) do
        if v == x then 
            found = true 
        end
    end
    return found
end

function file_exists(name)
    local f=io.open(name,"r")
    if f~=nil then
        io.close(f)
        return true
    else
        return false
    end
end

local tile_width = 8
local tile_height = 8
local padding = 4
local force_channels = 0
local colorspace = 0
local explode_list = {}
local input_files = {}
local out_files = {}
local zip_out = "assets.nice"
local keep_generated = false
local amalg_opts = {}
local reading_amalg_opts = false
local lua_files = {}
local main_lua = nil
local main_lua_out = "main.lua"
local temp_lua = nil

local i = 1
local last_asset_name = nil
local custom_names = {}  -- Store custom names for files
while i <= #arg do
    local a = arg[i]
    if reading_amalg_opts then
        table.insert(amalg_opts, a)
        goto continue
    end
    if a == "--help" or a == "-h" then
        print_usage()
        os.exit(0)
    elseif a == "-x" or a == "--explode" then
        next_arg = arg[i + 1] or error("Missing argument for " .. a)
        table.insert(explode_list, next_arg)
        last_asset_name = next_arg
        i = i + 1
    elseif a == "--as" or a == "-a" then
        if last_asset_name == nil then
            error("No previous asset to apply --as/-a to")
        end
        new_name = arg[i + 1] or error("Missing argument for " .. a)
        custom_names[last_asset_name] = new_name
        i = i + 1
    elseif a == "--channels" then
        force_channels = tonumber(arg[i + 1]) or error("Missing argument for --channels")
        if not force_channels or (force_channels ~= 0 and force_channels ~= 3 and force_channels ~= 4) then
            error("Channels must be 0 (auto), 3 (RGB), or 4 (RGBA)")
        end
        i = i + 1
    elseif a == "--colorspace" then
        colorspace = tonumber(arg[i + 1]) or error("Missing argument for --colorspace")
        if not colorspace or (colorspace ~= 0 and colorspace ~= 1) then
            error("Colorspace must be 0 (sRGB with linear alpha) or 1 (all linear)")
        end
        i = i + 1
    elseif a == "--width" then
        tile_width = tonumber(arg[i + 1]) or error("Missing argument for --width")
        if not tile_width or tile_width <= 0 then
            error("Width must be positive")
        end
        i = i + 1
    elseif a == "--height" then
        tile_height = tonumber(arg[i + 1]) or error("Missing argument for --height")
        if not tile_height or tile_height <= 0 then
            error("Height must be positive")
        end
        i = i + 1
    elseif a == "--padding" then
        padding = tonumber(arg[i + 1]) or error("Missing argument for --padding")
        if not padding or padding < 0 then
            error("Padding must be non-negative")
        end
        i = i + 1
    elseif a == "-o" or a == "--output" then
        zip_out = arg[i + 1] or error("Missing argument for -o/--output " .. a)
        i = i + 1
    elseif a == "-k" or a == "--keep" then
        keep_generated = true
    elseif a == "-m" or a == "--main" then
        main_lua = arg[i + 1] or error("Missing argument for -m/--main " .. a)
        i = i + 1
    elseif a == "--" then
        reading_amalg_opts = true
    else
        table.insert(input_files, a)
        last_asset_name = a  -- Track the last asset for --as option
    end
    ::continue::
    i = i + 1
end

for _, f in ipairs(explode_list) do
    print("Exploding file: " .. f)
    local new_name = explode_image(f, tile_width, tile_height, padding)
    table.insert(input_files, new_name)
    table.insert(out_files, new_name)
end

if #input_files == 0 then
    error("No input files specified")
end

for _, f in ipairs(input_files) do
    if not file_exists(f) then
        error("Input file does not exist: " .. f)
    end
    local ext = f:match("%.[^.]+$"):lower()
    if ext == ".png" or
       ext == ".jpg" or
       ext == ".jpeg" or
       ext == ".gif" or
       ext == ".bmp" or
       ext == ".tga" then
        table.insert(out_files, convert_to_qoi(f, force_channels, colorspace))
    elseif ext == ".wav" or
           ext == ".mp3" or
           ext == ".ogg" or
           ext == ".flac" then
        table.insert(out_files, convert_to_qoa(f))
    elseif ext == ".lua" then
        table.insert(lua_files, f)
    else
        table.insert(out_files, f)
    end
end

if main_lua ~= nil then
    if not table_contains(lua_files, main_lua) then
        table.insert(lua_files, main_lua)
    end
else
    if #lua_files > 0 then
        if table_contains(lua_files, "main.lua") then
            main_lua = "main.lua"
        else
            main_lua = lua_files[1]
        end
    else
        error("No Lua files to package, cannot determine main.lua")
    end
end

if #lua_files > 0 then
    temp_lua = os.tmpname() .. ".lua"
    print("Creating temporary Lua file: " .. temp_lua)
    local args = {"-o", temp_lua}
    if main_lua then
        table.insert(args, "-s")
        table.insert(args, main_lua)
    end
    for _, opt in ipairs(amalg_opts) do
        table.insert(args, opt)
    end
    if #lua_files > 1 then
        table.insert(args, "-v")
        for _, f in ipairs(lua_files) do
            if f ~= main_lua then
                table.insert(args, f)
            end
        end
    end
    for _, v in ipairs(args) do
        if type(v) == "table" then
            print("Amalg args: " .. table.concat(v, ", "))
        else
            print("Amalg args: " .. v)
        end
    end
    amalg.amalgamate(table.unpack(args))
    print("Lua amalgamation complete: " .. temp_lua)
    table.insert(out_files, temp_lua)
end

-- Create the final file mapping for the zip
local zip_files = {}

for _, f in ipairs(out_files) do
    if f and f ~= temp_lua then  -- Exclude temp_lua from regular processing
        -- check if file exists
        if not os.rename(f, f) then
            error("File does not exist: " .. f)
        else
            -- Check if this file has a custom name
            local entry_name = f
            -- Look for custom name based on original file that generated this output
            for original_file, custom_name in pairs(custom_names) do
                -- Check if this output file was generated from the original file
                if f:find(original_file:match("([^/]+)%.[^%.]+$"):gsub("%.", "%%%."), 1, true) then
                    entry_name = custom_name
                    break
                end
            end
            
            print("Packaging file: " .. f .. (entry_name ~= f and (" as " .. entry_name) or ""))
            zip_files[entry_name] = f
        end
    end
end

-- Add the main lua file with custom entry name
if temp_lua then
    -- Check if temp_lua exists
    if not os.rename(temp_lua, temp_lua) then
        error("Temp lua file does not exist: " .. temp_lua)
    else
        print("Packaging file: " .. temp_lua .. " as " .. main_lua_out)
        zip_files[main_lua_out] = temp_lua
    end
end

if nicepkg.create_zip(zip_out, zip_files) then
    print("ZIP created successfully at " .. zip_out)
else
    error("Failed to create ZIP file at " .. zip_out)
end

if not keep_generated then
    for _, f in ipairs(out_files) do
        if f then
            os.remove(f)
        end
    end
    if temp_lua then
        os.remove(temp_lua)
    end
end